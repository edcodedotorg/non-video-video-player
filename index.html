<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Editor (Single Threaded Fix)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

    <script type="module">
        import json from './example.json' with { type: 'json' }
        const jsonTextArea = document.querySelector('#video-json');
        jsonTextArea.textContent = JSON.stringify(json,null,"    ");
    </script>
    <style>
        :root { --primary-color: #3b82f6; }
        body { font-family: 'Inter', sans-serif; background-color: #f3fff6; }
        #video-container {
            aspect-ratio: 16 / 9; max-height: 80vh; border: 4px solid #1f2937;
            border-radius: 0.5rem; overflow: hidden; position: relative;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        iframe { width: 100%; height: 100%; border: none; background-color: white; pointer-events: none; }
        .loader {
            border: 3px solid #f3f3f3; border-top: 3px solid var(--primary-color);
            border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite;
            display: inline-block; vertical-align: middle; margin-right: 8px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto bg-white p-6 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-bold mb-6 text-gray-800">Programmatic Video Editor & Encoder</h1>

        <div class="grid grid-cols-1 lg:col-span-3 gap-8">
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Video JSON</h2>
                <textarea id="video-json" rows="10" class="w-full p-3 border border-gray-300 rounded-lg text-sm font-mono shadow-inner bg-gray-50" placeholder="Paste JSON here...">
                
                </textarea>
                <button id="load-btn" class="w-full bg-blue-600 text-white py-3 mt-4 rounded-lg font-semibold hover:bg-blue-700">Load & Prepare</button>
                <p id="message" class="mt-4 text-sm text-gray-600 min-h-6"></p>
                <audio id="main-audio-player" style="display: none;"></audio>
                <audio id="scene-audio-player" style="display: none;"></audio>
            </div>

            <div class="lg:col-span-2">
                <div id="video-container" class="mb-4">
                    <iframe id="scene-renderer" src="about:blank" scrolling="no"></iframe>
                    <div id="closed-caption-overlay" class="absolute inset-x-0 bottom-0 p-4 bg-black bg-opacity-70 text-white text-lg text-center hidden"></div>
                </div>

                <div class="space-y-4">
                    <div class="flex items-center space-x-4">
                        <span id="current-time-display" class="text-sm font-mono w-16 text-right">00:00.0</span>
                        <input type="range" id="timeline" min="0" max="1000" value="0" step="1" class="flex-grow">
                        <span id="total-duration-display" class="text-sm font-mono w-16">--:--.-</span>
                    </div>
                    <div class="flex justify-between">
                        <div class="space-x-2">
                            <button id="play-pause-btn" disabled class="px-4 py-2 bg-green-500 text-white rounded font-bold disabled:bg-gray-400">Play</button>
                            <button id="reset-btn" disabled class="px-4 py-2 bg-red-500 text-white rounded font-bold disabled:bg-gray-400">Reset</button>
                            <button id="encode-button" disabled class="px-4 py-2 bg-purple-600 text-white rounded font-bold disabled:bg-gray-400">Encode MP4</button>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="cc-toggle" checked>
                            <label for="cc-toggle" class="ml-2 text-sm font-medium text-gray-700">Captions</label>
                        </div>
                    </div>
                </div>

                <div id="encoding-status-panel" class="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded hidden">
                    <span id="status-message" class="flex items-center text-sm"></span>
                </div>
                <div id="video-output-container" class="mt-6 p-4 bg-green-50 border border-green-200 rounded hidden text-center">
                    <h3 class="text-lg font-bold mb-2">Output</h3>
                    <video id="output-video" controls class="w-full max-w-md mx-auto rounded shadow bg-black"></video>
                    <button id="download-button" class="mt-4 px-6 py-2 bg-blue-600 text-white rounded font-bold">Download</button>
                </div>
            </div>
        </div>
    </div>

   <script>
        // --- GLOBALS ---
        let ffmpeg = null;
        const FPS = 10;
        const FRAME_DURATION = 1000 / FPS;
        let videoData = null, processedScenes = [], totalDurationMs = 0;
        let isPlaying = false, currentTimeMs = 0, currentSceneIndex = 0;
        let animationFrameId = null, lastTimestamp = 0;

        // --- DOM ---
        const refs = {
            json: document.getElementById('video-json'),
            msg: document.getElementById('message'),
            renderer: document.getElementById('scene-renderer'),
            timeline: document.getElementById('timeline'),
            curTime: document.getElementById('current-time-display'),
            totTime: document.getElementById('total-duration-display'),
            playBtn: document.getElementById('play-pause-btn'),
            resetBtn: document.getElementById('reset-btn'),
            encodeBtn: document.getElementById('encode-button'),
            ccOverlay: document.getElementById('closed-caption-overlay'),
            ccToggle: document.getElementById('cc-toggle'),
            statusPanel: document.getElementById('encoding-status-panel'),
            statusEl: document.getElementById('status-message'),
            outputContainer: document.getElementById('video-output-container'),
            outputVideo: document.getElementById('output-video'),
            downloadBtn: document.getElementById('download-button'),
            loadBtn: document.getElementById('load-btn'),
            mainAudio: document.getElementById('main-audio-player'),
            sceneAudio: document.getElementById('scene-audio-player'),
            container: document.getElementById('video-container')
        };

        // --- HANDLERS ---
        refs.loadBtn.onclick = loadVideo;
        refs.playBtn.onclick = startStop;
        refs.resetBtn.onclick = resetVideo;
        refs.encodeBtn.onclick = encodeVideo;
        refs.timeline.oninput = (e) => seekTo(e.target.value);
        refs.ccToggle.onclick = () => { if(videoData) renderScene(currentSceneIndex); };

        // --- VIDEO LOGIC ---
        function parseDuration(str) {
            if (typeof str !== 'string') return 5000;
            const match = str.match(/^(\d+(\.\d+)?)(s)$/i);
            return match ? parseFloat(match[1]) * 1000 : 5000;
        }

        function calculateSceneDurations(data) {
            processedScenes = [];
            totalDurationMs = 0;
            const msPerWord = 500;
            data.scenes.forEach(scene => {
                let dur = scene.duration === "auto" 
                    ? (scene.speech ? scene.speech.split(/\s+/).filter(w => w.length).length * msPerWord : 2000)
                    : parseDuration(scene.duration);
                totalDurationMs += dur;
                processedScenes.push({ ...scene, durationMs: dur, startTimeMs: totalDurationMs - dur, endTimeMs: totalDurationMs });
            });
            refs.timeline.max = totalDurationMs;
            refs.totTime.textContent = formatTime(totalDurationMs);
        }

        function formatTime(ms) {
            if (isNaN(ms) || ms < 0) return "00:00.0";
            const s = Math.floor(ms / 1000), m = Math.floor(s / 60), sec = s % 60, tenths = Math.floor((ms % 1000) / 100);
            return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}.${tenths}`;
        }

        function renderScene(index) {
            if (index < 0 || index >= processedScenes.length) return;
            const scene = processedScenes[index];
            const doc = refs.renderer.contentDocument;
            
            doc.open();
            doc.write(scene.html);
            doc.close();
            if(doc.body) { doc.body.style.margin = '0'; doc.body.style.overflow = 'hidden'; }

            refs.ccOverlay.innerHTML = `<p>${scene.speech || ""}</p>`;
            refs.ccOverlay.style.display = (refs.ccToggle.checked && scene.speech) ? 'block' : 'none';

            const tScene = (currentTimeMs - scene.startTimeMs) / 1000;
            if (scene.audio) {
                if (refs.sceneAudio.src !== scene.audio) { refs.sceneAudio.src = scene.audio; refs.sceneAudio.load(); }
                if (tScene >= 0 && tScene < (refs.sceneAudio.duration || 999)) {
                    refs.sceneAudio.currentTime = tScene;
                    if (isPlaying) refs.sceneAudio.play().catch(()=>{});
                } else refs.sceneAudio.pause();
            } else { refs.sceneAudio.pause(); refs.sceneAudio.src = ""; }
        }

        function updateFrame(ts) {
            if (!isPlaying) return;
            if (!lastTimestamp) lastTimestamp = ts;
            currentTimeMs += (ts - lastTimestamp);
            lastTimestamp = ts;

            if (currentTimeMs >= totalDurationMs) { stopPlayback(); seekTo(totalDurationMs); return; }

            let newIdx = currentSceneIndex;
            while(newIdx < processedScenes.length && currentTimeMs >= processedScenes[newIdx].endTimeMs) newIdx++;
            if (newIdx !== currentSceneIndex) { currentSceneIndex = newIdx; renderScene(newIdx); }

            const scene = processedScenes[currentSceneIndex];
            if(refs.sceneAudio.duration && (currentTimeMs - scene.startTimeMs)/1000 >= refs.sceneAudio.duration) refs.sceneAudio.pause();

            refs.timeline.value = currentTimeMs;
            refs.curTime.textContent = formatTime(currentTimeMs);
            animationFrameId = requestAnimationFrame(updateFrame);
        }

        function startStop() {
            if (!videoData) return;
            if (isPlaying) stopPlayback();
            else {
                isPlaying = true;
                lastTimestamp = 0;
                if (currentTimeMs >= totalDurationMs) currentTimeMs = 0;
                if (refs.mainAudio.src) { refs.mainAudio.currentTime = currentTimeMs / 1000; refs.mainAudio.play().catch(()=>{}); }
                renderScene(currentSceneIndex);
                refs.playBtn.textContent = "Pause";
                refs.playBtn.classList.replace('bg-green-500', 'bg-yellow-500');
                animationFrameId = requestAnimationFrame(updateFrame);
            }
        }

        function stopPlayback() {
            isPlaying = false;
            cancelAnimationFrame(animationFrameId);
            refs.mainAudio.pause();
            refs.sceneAudio.pause();
            refs.playBtn.textContent = "Play";
            refs.playBtn.classList.replace('bg-yellow-500', 'bg-green-500');
        }

        function seekTo(val) {
            currentTimeMs = parseInt(val);
            let idx = processedScenes.findIndex(s => currentTimeMs >= s.startTimeMs && currentTimeMs < s.endTimeMs);
            if (idx === -1) idx = currentTimeMs >= totalDurationMs ? processedScenes.length - 1 : 0;
            currentSceneIndex = idx;
            renderScene(idx);
            refs.timeline.value = currentTimeMs;
            refs.curTime.textContent = formatTime(currentTimeMs);
            if (refs.mainAudio.src) refs.mainAudio.currentTime = currentTimeMs / 1000;
        }

        function loadVideo() {
            stopPlayback();
            try {
                const data = JSON.parse(refs.json.value.trim());
                if (!data.scenes || !data.scenes.length) throw new Error("No scenes found");
                videoData = data;
                calculateSceneDurations(data);
                if (videoData.audio) { refs.mainAudio.src = videoData.audio; refs.mainAudio.load(); }
                else refs.mainAudio.src = "";
                
                currentSceneIndex = 0; currentTimeMs = 0; seekTo(0);
                refs.playBtn.disabled = refs.resetBtn.disabled = refs.encodeBtn.disabled = false;
                refs.msg.textContent = "Video Loaded!"; refs.msg.className = "mt-4 text-sm text-green-600";
            } catch(e) { refs.msg.textContent = e.message; refs.msg.className = "mt-4 text-sm text-red-600"; }
        }

        function resetVideo() { stopPlayback(); seekTo(0); }

        // --- ENCODING LOGIC (Fixed) ---

        async function initFFmpeg() {
            if (ffmpeg) return;
            const { createFFmpeg } = FFmpeg;

            // FIX: Removed manual blob patching. 
            // We load the Single Threaded core via CDN directly and 
            // set 'mainName' to 'main' so it doesn't look for 'proxy_main'.
            ffmpeg = createFFmpeg({
                log: true,
                corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js',
                mainName: 'main'
            });

            await ffmpeg.load();
        }

        async function captureFrame(t, count) {
            seekTo(t);
            // Increased delay slightly to ensure DOM reflow is complete before capture
            await new Promise(r => setTimeout(r, 100)); 

            const canvas = await html2canvas(refs.container, {
                ignoreElements: el => el.id === 'scene-renderer',
                useCORS: true, allowTaint: true,
                onclone: (clonedDoc) => {
                    const ifr = refs.renderer;
                    const cContainer = clonedDoc.getElementById('video-container');
                    const cIfr = clonedDoc.getElementById('scene-renderer');
                    if (ifr && cContainer) {
                        const div = clonedDoc.createElement('div');
                        Object.assign(div.style, {
                            width: '100%', height: '100%', position: 'absolute', top: 0, left: 0, backgroundColor: 'white'
                        });
                        // Capture the innerHTML of the iframe
                        try {
                            if(ifr.contentDocument) {
                                div.innerHTML = ifr.contentDocument.documentElement.outerHTML;
                            }
                        } catch(e) { console.warn("Cross-origin iframe access blocked"); }
                        
                        cContainer.insertBefore(div, cIfr);
                        if(cIfr) cIfr.style.display = 'none';
                        const cc = clonedDoc.getElementById('closed-caption-overlay');
                        if(cc) cc.style.display = refs.ccToggle.checked ? 'block' : 'none';
                    }
                }
            });

            const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
            const buf = await blob.arrayBuffer();
            const fname = `frame_${String(count).padStart(4,'0')}.png`;
            ffmpeg.FS('writeFile', fname, new Uint8Array(buf));
        }

        async function encodeVideo() {
            if (!videoData) return;
            stopPlayback();
            refs.encodeBtn.disabled = true;
            refs.statusPanel.classList.remove('hidden');
            refs.outputContainer.classList.add('hidden');
            refs.statusEl.innerHTML = '<div class="loader"></div> Loading FFmpeg...';

            try {
                await initFFmpeg();

                const totalFrames = Math.ceil(totalDurationMs / FRAME_DURATION);
                let count = 0;

                // Capture Loop
                for (let t = 0; t < totalDurationMs; t += FRAME_DURATION) {
                    count++;
                    refs.statusEl.innerHTML = `<div class="loader"></div> Capturing Frame ${count} / ${totalFrames}`;
                    await captureFrame(t, count);
                }

                refs.statusEl.innerHTML = '<div class="loader"></div> Encoding MP4...';
                
                // Audio Handling
                const args = ['-framerate', `${FPS}`, '-i', 'frame_%04d.png'];
                let hasAudio = false;

                if (videoData.audio && videoData.audio.startsWith('data:audio')) {
                    try {
                        const ab = await (await fetch(videoData.audio)).arrayBuffer();
                        ffmpeg.FS('writeFile', 'audio.mp3', new Uint8Array(ab));
                        args.push('-i', 'audio.mp3', '-c:a', 'aac', '-shortest');
                        hasAudio = true;
                    } catch(e) { console.error("Audio processing failed", e); }
                }

                // Video Encoding Args
                // -pix_fmt yuv420p is essential for compatibility with Windows/QuickTime
                args.push('-c:v', 'libx264', '-pix_fmt', 'yuv420p', 'output.mp4');
                
                await ffmpeg.run(...args);

                const data = ffmpeg.FS('readFile', 'output.mp4');
                const url = URL.createObjectURL(new Blob([data.buffer], {type: 'video/mp4'}));
                refs.outputVideo.src = url;
                refs.downloadBtn.onclick = () => {
                    const a = document.createElement('a'); a.href = url; a.download = 'video.mp4'; a.click();
                };

                refs.statusEl.textContent = "Done!";
                refs.outputContainer.classList.remove('hidden');

                // Cleanup to free memory
                try { ffmpeg.FS('unlink', 'output.mp4'); } catch(e){}
                if(hasAudio) try { ffmpeg.FS('unlink', 'audio.mp3'); } catch(e){}
                for(let i=1; i<=count; i++) try { ffmpeg.FS('unlink', `frame_${String(i).padStart(4,'0')}.png`); } catch(e){}

            } catch(e) {
                console.error(e);
                refs.statusEl.textContent = "Error: " + e.message;
            } finally {
                refs.encodeBtn.disabled = false;
                seekTo(0);
            }
        }
    </script>
</body>
</html>